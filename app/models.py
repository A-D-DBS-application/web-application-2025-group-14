from datetime import datetime #voor datum


from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

#tabel creëren met bijhorende kolommen
class lifecycle(db.Model):
    lifecycle = db.Column(db.String, primary_key=True) #String ipv. text (SQL)

    #zodat navigatie mogelijk: van lifecycle → naar alle materialen (EN) van materiaal → terug naar lifecycle
    #lazy=True: SQLAlchemy laadt de lijst pas wanneer je ernaar vraagt
    materialen = db.relationship('materiaal', backref='lifecycle', lazy=True)

    #bepaalt hoe het object wordt weergegeven als tekst (handig bij debuggen)
    def __repr__(self):
        return f'<lifecycle {self.lifecycle}>'


class materiaal(db.Model):
    materiaal_id = db.Column(db.Integer, primary_key=True) #GENERATED BY DEFAULT AS IDENTITY (SQL)
    type = db.Column(db.String, nullable=False)
    omschrijving = db.Column(db.String, nullable=False)
    lifecycle = db.Column(db.String, db.ForeignKey('lifecycle.lifecycle', ondelete="RESTRICT", onupdate="CASCADE"))
    merk = db.Column(db.String, nullable=False)
    prijs = db.Column(db.Float) #Float ipv. Numeric (SQL)

    #contraints toevoegen
    __table_args__ = (
        db.UniqueConstraint('type', 'omschrijving', name='UC1'),
        )

    items = db.relationship('item', backref='materiaal', lazy=True)

    def __repr__(self):
        return f"<Materiaal id={self.materiaal_id}, type={self.type}>" #geen omschrijving want vaak te lang


class zone(db.Model):
    zone = db.Column(db.String, primary_key=True)

    items = db.relationship('item', backref='zone', lazy=True)

    def __repr__(self):
        return f'<zone {self.zone}>'


class item(db.Model):
    item_id = db.Column(db.Integer, primary_key=True) #GENERATED BY DEFAULT AS IDENTITY (SQL)
    materiaal_id = db.Column(db.Integer, db.ForeignKey('materiaal.materiaal_id', ondelete="RESTRICT", onupdate="CASCADE"), nullable=False)
    zone = db.Column(db.String, db.ForeignKey('zone.zone', ondelete="RESTRICT", onupdate="CASCADE"), nullable=False)
    doel = db.Column(db.String, nullable=False)
    verpakking = db.Column(db.String, nullable=False)
    aantal = db.Column(db.Integer, nullable=False)
    comment = db.Column(db.String)

    __table_args__ = (
        db.UniqueConstraint('materiaal_id', 'zone', 'doel', 'verpakking', name='UC2'),
        db.CheckConstraint("doel IN ('to keep', 'for sale', 'to be thrown away')", name='CC2'),
        db.CheckConstraint("verpakking IN ('open', 'gesloten', 'geen')", name='CC3'),
    )

    gebruiken = db.relationship('gebruik', backref='item', lazy=True)

    def __repr__(self):
        return f"<Item id={self.item_id}, materiaal={self.materiaal_id}, zone={self.zone}>"


class gebruik(db.Model):
    item_id = db.Column(db.Integer, db.ForeignKey('item.item_id', ondelete="CASCADE", onupdate="CASCADE"), primary_key=True)
    gebruiker = db.Column(db.String, primary_key=True)
    datum = db.Column(db.DateTime, server_default=db.func.current_timestamp(), primary_key=True) #timestamp DEFAULT CURRENT_TIMESTAMP (SQL)
    hoeveelheid = db.Column(db.Integer, nullable=False)
    project = db.Column(db.String)
    reservatie = db.Column(db.String)

    #geen relationship nodig, want we navigeren al van item → gebruik

    def __repr__(self):
        return f"<Gebruik item={self.item_id}, gebruiker={self.gebruiker}, datum={self.datum}>" #PK